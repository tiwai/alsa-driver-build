--- ../alsa-kernel/core/info.c	2015-05-18 11:26:57.088632828 +0200
+++ info.c	2015-05-19 13:16:49.230323229 +0200
@@ -1,3 +1,7 @@
+#define __NO_VERSION__
+#include "adriver.h"
+#include "alsa-autoconf.h"
+
 /*
  *  Information interface for ALSA driver
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
@@ -114,6 +118,25 @@
 	return true;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+static void snd_remove_proc_entry(struct proc_dir_entry *parent,
+				  struct proc_dir_entry *de)
+{
+	if (de)
+		remove_proc_entry(de->name, parent);
+}
+
+#define proc_set_size(p, s)	((p)->size = (s))
+
+static void *PDE_DATA(struct inode *inode)
+{
+	struct proc_dir_entry *p = PDE(inode);
+	if (p)
+		return p->data;
+	return NULL;
+}	
+#endif
+
 /*
  * file ops for binary proc files
  */
@@ -232,9 +255,28 @@
 				   file, cmd, arg);
 }
 
+#ifndef CONFIG_SND_HAVE_NEW_IOCTL
+/* need to unlock BKL to allow preemption */
+static int snd_info_entry_ioctl_old(struct inode *inode, struct file * file,
+				    unsigned int cmd, unsigned long arg)
+{
+	int err;
+	unlock_kernel();
+	err = snd_info_entry_ioctl(file, cmd, arg);
+	lock_kernel();
+	return err;
+}
+#endif
+
 static int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 	struct inode *inode = file_inode(file);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+	struct inode *inode = file->f_path.dentry->d_inode;
+#else
+	struct inode *inode = file->f_dentry->d_inode;
+#endif
 	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
 
@@ -304,7 +346,11 @@
 	.read =			snd_info_entry_read,
 	.write =		snd_info_entry_write,
 	.poll =			snd_info_entry_poll,
+#ifdef CONFIG_SND_HAVE_NEW_IOCTL
 	.unlocked_ioctl =	snd_info_entry_ioctl,
+#else
+	.ioctl =		snd_info_entry_ioctl_old,
+#endif
 	.mmap =			snd_info_entry_mmap,
 	.open =			snd_info_entry_open,
 	.release =		snd_info_entry_release,
@@ -339,12 +385,21 @@
 		}
 	}
 	if (next > buf->len) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22) || \
+	defined(CONFIG_SND_DEBUG_MEMORY)
+		char *nbuf = kzalloc(PAGE_ALIGN(next), GFP_KERNEL);
+		if (!nbuf)
+			return -ENOMEM;
+		memcpy(nbuf, buf->buffer, buf->len);
+		kfree(buf->buffer);
+#else	
 		char *nbuf = krealloc(buf->buffer, PAGE_ALIGN(next),
 				      GFP_KERNEL | __GFP_ZERO);
 		if (!nbuf) {
 			err = -ENOMEM;
 			goto error;
 		}
+#endif
 		buf->buffer = nbuf;
 		buf->len = PAGE_ALIGN(next);
 	}
@@ -458,6 +513,12 @@
 static struct snd_info_entry *
 snd_info_create_entry(const char *name, struct snd_info_entry *parent);
 
+#if defined(CONFIG_SND_DEBUG_MEMORY) && defined(CONFIG_PROC_FS)
+extern int snd_memory_info_init(void);
+#else
+#define snd_memory_info_init()	0
+#endif
+
 int __init snd_info_init(void)
 {
 	snd_proc_root = snd_info_create_entry("asound", NULL);
@@ -481,6 +542,7 @@
 	    snd_minor_info_init() < 0 ||
 	    snd_minor_info_oss_init() < 0 ||
 	    snd_card_info_init() < 0 ||
+	    snd_memory_info_init() < 0 ||
 	    snd_info_minor_register() < 0)
 		goto error;
 	return 0;
@@ -573,7 +635,11 @@
 {
 	mutex_lock(&info_mutex);
 	if (card->proc_root_link) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+		snd_remove_proc_entry(snd_proc_root->p, card->proc_root_link);
+#else
 		proc_remove(card->proc_root_link);
+#endif
 		card->proc_root_link = NULL;
 	}
 	if (strcmp(card->id, card->proc_root->name))
@@ -592,7 +658,11 @@
 	if (!card)
 		return;
 	mutex_lock(&info_mutex);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+	snd_remove_proc_entry(snd_proc_root->p, card->proc_root_link);
+#else
 	proc_remove(card->proc_root_link);
+#endif
 	card->proc_root_link = NULL;
 	if (card->proc_root)
 		snd_info_disconnect(card->proc_root);
@@ -776,7 +846,20 @@
 		return;
 	list_for_each_entry(p, &entry->children, list)
 		snd_info_disconnect(p);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+	{
+		struct proc_dir_entry *root;
+		if (entry == snd_proc_root)
+			root = NULL;
+		else if (entry->parent)
+			root = entry->parent->p;
+		else
+			root = snd_proc_root->p;
+		snd_remove_proc_entry(root, entry->p);
+	}
+#else
 	proc_remove(entry->p);
+#endif
 	entry->p = NULL;
 }
 
@@ -827,6 +910,23 @@
 		return -ENXIO;
 	root = entry->parent == NULL ? snd_proc_root->p : entry->parent->p;
 	mutex_lock(&info_mutex);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+	p = create_proc_entry(entry->name, entry->mode, root);
+	if (!p) {
+		mutex_unlock(&info_mutex);
+		return -ENOMEM;
+	}
+	if (!S_ISDIR(entry->mode)) {
+		const struct file_operations *ops;
+		if (entry->content == SNDRV_INFO_CONTENT_DATA)
+			ops = &snd_info_entry_operations;
+		else
+			ops = &snd_info_text_entry_ops;
+		p->proc_fops = ops;
+	}
+	p->size = entry->size;
+	p->data = entry;
+#else
 	if (S_ISDIR(entry->mode)) {
 		p = proc_mkdir_mode(entry->name, entry->mode, root);
 		if (!p) {
@@ -847,6 +947,7 @@
 		}
 		proc_set_size(p, entry->size);
 	}
+#endif
 	entry->p = p;
 	mutex_unlock(&info_mutex);
 	return 0;
@@ -860,9 +961,20 @@
 
 static void snd_info_version_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
+	static char *kernel_version = UTS_RELEASE;
+
 	snd_iprintf(buffer,
-		    "Advanced Linux Sound Architecture Driver Version k%s.\n",
-		    init_utsname()->release);
+		    "Advanced Linux Sound Architecture Driver Version "
+		    CONFIG_SND_VERSION ".\n"
+		    "Compiled on " __DATE__ " for kernel %s"
+#ifdef CONFIG_SMP
+		    " (SMP)"
+#endif
+#ifdef MODVERSIONS
+		    " with versioned symbols"
+#endif
+		    ".\n", kernel_version
+		    );
 }
 
 static int __init snd_info_version_init(void)
